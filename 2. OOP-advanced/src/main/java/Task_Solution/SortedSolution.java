package Task_Solution;

/**
 * Класс SortedSolution
 */

/*
* Псевдокод
Данный псевдокод используется для описания алгоритмов.

1. Отступ от левого поля указывает на уровень вложенности.
2. Циклы while, for, repeat и условные конструкции имеют тот же смысл, что и в pascal-е.
3. Символ “--” обозначает комментарий
4. Символ “:=” обозначает присваивание
5. Переменные локальны в рамках процедуры, если не оговорено иначе
6. Индекс массива пишется в квадратных скобках, конструкция A[i] означает i элемент в массиве A
7. Возможно использование объектов, состоящих из нескольких полей, или имеющих несколько атрибутов, значения поля записывается как ИмяПоля[ИмяОбъекта].
К примеру, длина массива A записывается как Length[A]; что означают квадратные скобки - выясняется по контексту (переменная, обозначающая массив, или объект является указателем на составляющие его данные). После присвоения y:=x для любого поля f будет выполняться равенство f[y]=f[x]; определение того, что является атрибутом – функция, переменная или что-либо еще, - делается по контексту.
8. Указатель может иметь специальное значение NIL, не указывающее ни на какой объект.
9. Параметры передаются по значению: вызванная процедура получает собственную копию параметров, изменения параметров внутри процедуры снаружи не видно. При передаче объектов копируется указатель на данные, соответствующие этому объекту.



Задача

Функция сортирующая массив элементов A:
Sort(A,p,r)
1 if p < r
2    then           q := round_half_down((p+r)/2)
3                       Sort(A,p,q)
4                       Sort(A,q+1,r)
5                       Merge(A,p,q,r)

Пример массива:
A = (5,2,4,6,1,3,2,6)

Примера запуска:
Sort(A,1,length[A])


Необходимо:
Разработать алгоритм функции Merge(A,p,q,r) на языке Java.

*
* */

public class SortedSolution {

	public static void main(String[] args) {
		int[] massif = {13, 3, 8, 1, 15, 2, 3, 7, 4};
		System.out.print("Массив до сортировки: ");
		for (int i = 0; i < massif.length; i++)
			System.out.print(massif[i] + " ");
		System.out.println("");
		massif = sort(massif);
		System.out.print("Массив после сортировки: ");
		for (int i = 0; i < massif.length; i++)
			System.out.print(massif[i] + " ");
	}

	public static int[] sort(int x[]) {
		if (x.length == 1) //Рекурсия идет до тех пор, пока массив делится
			return x;
		else {
			int half = (int) Math.floor(x.length / 2); //Разбиваем массив на 2 части
			int halfFirst[] = new int[half]; //1 часть, пустой массив
			int halfSecond[] = new int[x.length - half]; //2 часть, пустой массив
			for (int i = 0; i < x.length; i++) { //Заполняем новосозданные массивы значениями
				if (i < half)
					halfFirst[i] = x[i];
				else
					halfSecond[i - half] = x[i];
			}
			halfFirst = sort(halfFirst); //Рекурсия
			halfSecond = sort(halfSecond); //Рекурсия
			x = sortNext(halfFirst, halfSecond); //Отправляем заполненные значениями массивы в следующий метод
			return x;
		}
	}

	public static int[] sortNext(int x[], int y[]) {
		int c[] = new int[x.length + y.length]; //Создаем результирующий массив из суммы длин массивов из аргументов метода
		int a = 0, b = 0;
		for (int i = 0; i < x.length + y.length; i++) { //Сравниваем массивы, меняем местами элементы, заполняем новосозданный массив
			if (a == x.length) {
				c[i] = y[b];
				b++;
			} else if (b == y.length) {
				c[i] = x[a];
				a++;
			} else if (x[a] > y[b]) {
				c[i] = y[b];
				b++;
			} else {
				c[i] = x[a];
				a++;
			}
		}
		return c;
	}
}